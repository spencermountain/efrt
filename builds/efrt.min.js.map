{"version":3,"file":"efrt.min.js","sources":["../src/pack/fns.js","../src/pack/histogram.js","../src/encoding.js","../src/pack/pack.js","../src/pack/methods.js","../src/pack/trie.js","../src/pack/index.js","../src/unpack/symbols.js","../src/unpack/unpack.js","../src/unpack/index.js","../src/index.js"],"sourcesContent":["const commonPrefix = function(w1, w2) {\n  let len = Math.min(w1.length, w2.length)\n  while (len > 0) {\n    const prefix = w1.slice(0, len)\n    if (prefix === w2.slice(0, len)) {\n      return prefix\n    }\n    len -= 1\n  }\n  return ''\n}\n\n/* Sort elements and remove duplicates from array (modified in place) */\nconst unique = function(a) {\n  a.sort()\n  for (let i = 1; i < a.length; i++) {\n    if (a[i - 1] === a[i]) {\n      a.splice(i, 1)\n    }\n  }\n}\n\nmodule.exports = {\n  commonPrefix: commonPrefix,\n  unique: unique\n}\n","const Histogram = function() {\n  this.counts = {}\n}\n\nconst methods = {\n  init: function(sym) {\n    if (this.counts[sym] === undefined) {\n      this.counts[sym] = 0\n    }\n  },\n  add: function(sym, n) {\n    if (n === undefined) {\n      n = 1\n    }\n    this.init(sym)\n    this.counts[sym] += n\n  },\n  countOf: function(sym) {\n    this.init(sym)\n    return this.counts[sym]\n  },\n  highest: function(top) {\n    let sorted = []\n    const keys = Object.keys(this.counts)\n    for (let i = 0; i < keys.length; i++) {\n      const sym = keys[i]\n      sorted.push([sym, this.counts[sym]])\n    }\n    sorted.sort(function(a, b) {\n      return b[1] - a[1]\n    })\n    if (top) {\n      sorted = sorted.slice(0, top)\n    }\n    return sorted\n  }\n}\nObject.keys(methods).forEach(function(k) {\n  Histogram.prototype[k] = methods[k]\n})\nmodule.exports = Histogram\n","'use strict'\nconst BASE = 36\n\nconst seq = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nconst cache = seq.split('').reduce(function(h, c, i) {\n  h[c] = i\n  return h\n}, {})\n\n// 0, 1, 2, ..., A, B, C, ..., 00, 01, ... AA, AB, AC, ..., AAA, AAB, ...\nconst toAlphaCode = function(n) {\n  if (seq[n] !== undefined) {\n    return seq[n]\n  }\n  let places = 1\n  let range = BASE\n  let s = ''\n\n  for (; n >= range; n -= range, places++, range *= BASE) {}\n  while (places--) {\n    const d = n % BASE\n    s = String.fromCharCode((d < 10 ? 48 : 55) + d) + s\n    n = (n - d) / BASE\n  }\n  return s\n}\n\nconst fromAlphaCode = function(s) {\n  if (cache[s] !== undefined) {\n    return cache[s]\n  }\n  let n = 0\n  let places = 1\n  let range = BASE\n  let pow = 1\n\n  for (; places < s.length; n += range, places++, range *= BASE) {}\n  for (let i = s.length - 1; i >= 0; i--, pow *= BASE) {\n    let d = s.charCodeAt(i) - 48\n    if (d > 10) {\n      d -= 7\n    }\n    n += d * pow\n  }\n  return n\n}\n\nmodule.exports = {\n  toAlphaCode: toAlphaCode,\n  fromAlphaCode: fromAlphaCode\n}\n","const Histogram = require('./histogram')\nconst encoding = require('../encoding')\nconst config = {\n  NODE_SEP: ';',\n  KEY_VAL: ':',\n  STRING_SEP: ',',\n  TERMINAL_PREFIX: '!',\n  BASE: 36\n}\n\n// Return packed representation of Trie as a string.\n\n// Return packed representation of Trie as a string.\n//\n// Each node of the Trie is output on a single line.\n//\n// For example Trie(\"the them there thesis this\"):\n// {\n//    \"th\": {\n//      \"is\": 1,\n//      \"e\": {\n//        \"\": 1,\n//        \"m\": 1,\n//        \"re\": 1,\n//        \"sis\": 1\n//      }\n//    }\n//  }\n//\n// Would be reperesented as:\n//\n// th0\n// e0is\n// !m,re,sis\n//\n// The line begins with a '!' iff it is a terminal node of the Trie.\n// For each string property in a node, the string is listed, along\n// with a (relative!) line number of the node that string references.\n// Terminal strings (those without child node references) are\n// separated by ',' characters.\n\nconst nodeLine = function(self, node) {\n  let line = '',\n    sep = ''\n\n  if (self.isTerminal(node)) {\n    line += config.TERMINAL_PREFIX\n  }\n\n  const props = self.nodeProps(node)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    if (typeof node[prop] === 'number') {\n      line += sep + prop\n      sep = config.STRING_SEP\n      continue\n    }\n    if (self.syms[node[prop]._n]) {\n      line += sep + prop + self.syms[node[prop]._n]\n      sep = ''\n      continue\n    }\n    let ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount)\n    // Large reference to smaller string suffix -> duplicate suffix\n    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {\n      ref = node[prop]._g\n      line += sep + prop + ref\n      sep = config.STRING_SEP\n      continue\n    }\n    line += sep + prop + ref\n    sep = ''\n  }\n  return line\n}\n\nconst analyzeRefs = function(self, node) {\n  if (self.visited(node)) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    const ref = node._n - node[prop]._n - 1\n    // Count the number of single-character relative refs\n    if (ref < config.BASE) {\n      self.histRel.add(ref)\n    }\n    // Count the number of characters saved by converting an absolute\n    // reference to a one-character symbol.\n    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1)\n    analyzeRefs(self, node[prop])\n  }\n}\n\nconst symbolCount = function(self) {\n  self.histAbs = self.histAbs.highest(config.BASE)\n  const savings = []\n  savings[-1] = 0\n  let best = 0,\n    sCount = 0\n  const defSize = 3 + encoding.toAlphaCode(self.nodeCount).length\n  for (let sym = 0; sym < config.BASE; sym++) {\n    if (self.histAbs[sym] === undefined) {\n      break\n    }\n    savings[sym] =\n      self.histAbs[sym][1] -\n      defSize -\n      self.histRel.countOf(config.BASE - sym - 1) +\n      savings[sym - 1]\n    if (savings[sym] >= best) {\n      best = savings[sym]\n      sCount = sym + 1\n    }\n  }\n  return sCount\n}\n\nconst numberNodes = function(self, node) {\n  // Topological sort into nodes array\n  if (node._n !== undefined) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    numberNodes(self, node[props[i]]) //recursive\n  }\n  node._n = self.pos++\n  self.nodes.unshift(node)\n}\n\nconst pack = function(self) {\n  self.nodes = []\n  self.nodeCount = 0\n  self.syms = {}\n  self.symCount = 0\n  self.pos = 0\n  // Make sure we've combined all the common suffixes\n  self.optimize()\n\n  self.histAbs = new Histogram()\n  self.histRel = new Histogram()\n\n  numberNodes(self, self.root)\n  self.nodeCount = self.nodes.length\n\n  self.prepDFS()\n  analyzeRefs(self, self.root)\n  self.symCount = symbolCount(self)\n  for (let sym = 0; sym < self.symCount; sym++) {\n    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym)\n  }\n  for (let i = 0; i < self.nodeCount; i++) {\n    self.nodes[i] = nodeLine(self, self.nodes[i])\n  }\n  // Prepend symbols\n  for (let sym = self.symCount - 1; sym >= 0; sym--) {\n    self.nodes.unshift(\n      encoding.toAlphaCode(sym) +\n        config.KEY_VAL +\n        encoding.toAlphaCode(self.nodeCount - self.histAbs[sym][0] - 1)\n    )\n  }\n\n  return self.nodes.join(config.NODE_SEP)\n}\n\nmodule.exports = pack\n","const fns = require('./fns')\nconst pack = require('./pack')\nconst NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|¦]') //characters banned from entering the trie\n\nmodule.exports = {\n  // Insert words from one big string, or from an array.\n  insertWords: function(words) {\n    if (words === undefined) {\n      return\n    }\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/)\n    }\n    for (let i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase()\n    }\n    fns.unique(words)\n    for (let i = 0; i < words.length; i++) {\n      if (words[i].match(NOT_ALLOWED) === null) {\n        this.insert(words[i])\n      }\n    }\n  },\n\n  insert: function(word) {\n    this._insert(word, this.root)\n    const lastWord = this.lastWord\n    this.lastWord = word\n\n    const prefix = fns.commonPrefix(word, lastWord)\n    if (prefix === lastWord) {\n      return\n    }\n\n    const freeze = this.uniqueNode(lastWord, word, this.root)\n    if (freeze) {\n      this.combineSuffixNode(freeze)\n    }\n  },\n\n  _insert: function(word, node) {\n    let prefix, next\n\n    // Duplicate word entry - ignore\n    if (word.length === 0) {\n      return\n    }\n\n    // Do any existing props share a common prefix?\n    const keys = Object.keys(node)\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i]\n      prefix = fns.commonPrefix(word, prop)\n      if (prefix.length === 0) {\n        continue\n      }\n      // Prop is a proper prefix - recurse to child node\n      if (prop === prefix && typeof node[prop] === 'object') {\n        this._insert(word.slice(prefix.length), node[prop])\n        return\n      }\n      // Duplicate terminal string - ignore\n      if (prop === word && typeof node[prop] === 'number') {\n        return\n      }\n      next = {}\n      next[prop.slice(prefix.length)] = node[prop]\n      this.addTerminal(next, word = word.slice(prefix.length))\n      delete node[prop]\n      node[prefix] = next\n      this.wordCount++\n      return\n    }\n\n    // No shared prefix.  Enter the word here as a terminal string.\n    this.addTerminal(node, word)\n    this.wordCount++\n  },\n\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value == 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal: function(node, prop) {\n    if (prop.length <= 1) {\n      node[prop] = 1\n      return\n    }\n    const next = {}\n    node[prop[0]] = next\n    this.addTerminal(next, prop.slice(1))\n  },\n\n  // Well ordered list of properties in a node (string or object properties)\n  // Use nodesOnly==true to return only properties of child nodes (not\n  // terminal strings.\n  nodeProps: function(node, nodesOnly) {\n    const props = []\n    for (const prop in node) {\n      if (prop !== '' && prop[0] !== '_') {\n        if (!nodesOnly || typeof node[prop] === 'object') {\n          props.push(prop)\n        }\n      }\n    }\n    props.sort()\n    return props\n  },\n\n  optimize: function() {\n    this.combineSuffixNode(this.root)\n    this.prepDFS()\n    this.countDegree(this.root)\n    this.prepDFS()\n    this.collapseChains(this.root)\n  },\n\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode: function(node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node\n    }\n    // Make sure all children are combined and generate unique node\n    // signature for this node.\n    let sig = []\n    if (this.isTerminal(node)) {\n      sig.push('!')\n    }\n    const props = this.nodeProps(node)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (typeof node[prop] === 'object') {\n        node[prop] = this.combineSuffixNode(node[prop])\n        sig.push(prop)\n        sig.push(node[prop]._c)\n      } else {\n        sig.push(prop)\n      }\n    }\n    sig = sig.join('-')\n\n    const shared = this.suffixes[sig]\n    if (shared) {\n      return shared\n    }\n    this.suffixes[sig] = node\n    node._c = this.cNext++\n    return node\n  },\n\n  prepDFS: function() {\n    this.vCur++\n  },\n\n  visited: function(node) {\n    if (node._v === this.vCur) {\n      return true\n    }\n    node._v = this.vCur\n    return false\n  },\n\n  countDegree: function(node) {\n    if (node._d === undefined) {\n      node._d = 0\n    }\n    node._d++\n    if (this.visited(node)) {\n      return\n    }\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      this.countDegree(node[props[i]])\n    }\n  },\n\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains: function(node) {\n    let prop, props, child, i\n    if (this.visited(node)) {\n      return\n    }\n    props = this.nodeProps(node)\n    for (i = 0; i < props.length; i++) {\n      prop = props[i]\n      child = node[prop]\n      if (typeof child !== 'object') {\n        continue\n      }\n      this.collapseChains(child)\n      // Hoist the singleton child's single property to the parent\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        delete node[prop]\n        prop += child._g\n        node[prop] = child[child._g]\n      }\n    }\n    // Identify singleton nodes\n    if (props.length === 1 && !this.isTerminal(node)) {\n      node._g = prop\n    }\n  },\n\n  isTerminal: function(node) {\n    return !!node['']\n  },\n\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode: function(word, other, node) {\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node[prop]\n        }\n        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop])\n      }\n    }\n    return undefined\n  },\n\n  pack: function() {\n    return pack(this)\n  }\n}\n","const methods = require('./methods')\n/*\n A JavaScript implementation of a Trie search datastructure.\nEach node of the Trie is an Object that can contain the following properties:\n      '' - If present (with value == 1), the node is a Terminal Node - the prefix\n          leading to this node is a word in the dictionary.\n      numeric properties (value == 1) - the property name is a terminal string\n          so that the prefix + string is a word in the dictionary.\n      Object properties - the property name is one or more characters to be consumed\n          from the prefix of the test string, with the remainder to be checked in\n          the child node.\n      '_c': A unique name for the node (starting from 1), used in combining Suffixes.\n      '_n': Created when packing the Trie, the sequential node number\n          (in pre-order traversal).\n      '_d': The number of times a node is shared (it's in-degree from other nodes).\n      '_v': Visited in DFS.\n      '_g': For singleton nodes, the name of it's single property.\n */\nconst Trie = function(words) {\n  this.root = {}\n  this.lastWord = ''\n  this.suffixes = {}\n  this.suffixCounts = {}\n  this.cNext = 1\n  this.wordCount = 0\n  this.insertWords(words)\n  this.vCur = 0\n}\nObject.keys(methods).forEach(function(k) {\n  Trie.prototype[k] = methods[k]\n})\nmodule.exports = Trie\n","const Trie = require('./trie')\n\nconst isArray = function(input) {\n  return Object.prototype.toString.call(input) === '[object Array]'\n}\n\nconst handleFormats = function(input) {\n  //null\n  if (input === null || input === undefined) {\n    return {}\n  }\n  //string\n  if (typeof input === 'string') {\n    return input.split(/ +/g).reduce(function(h, str) {\n      h[str] = true\n      return h\n    }, {})\n  }\n  //array\n  if (isArray(input)) {\n    return input.reduce(function(h, str) {\n      h[str] = true\n      return h\n    }, {})\n  }\n  //object\n  return input\n}\n\n//turn an array into a compressed string\nconst pack = function(obj) {\n  obj = handleFormats(obj)\n  //pivot into categories:\n  const flat = Object.keys(obj).reduce(function(h, k) {\n    const val = obj[k]\n    //array version-\n    //put it in several buckets\n    if (isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        h[val[i]] = h[val[i]] || []\n        h[val[i]].push(k)\n      }\n      return h\n    }\n    //normal string/boolean version\n    if (h.hasOwnProperty(val) === false) {\n      //basically h[val]=[]  - support reserved words\n      Object.defineProperty(h, val, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: []\n      })\n    }\n    h[val].push(k)\n    return h\n  }, {})\n  //pack each into a compressed string\n  Object.keys(flat).forEach(function(k) {\n    const t = new Trie(flat[k])\n    flat[k] = t.pack()\n  })\n  // flat = JSON.stringify(flat, null, 0);\n\n  return Object.keys(flat)\n    .map(k => {\n      return k + '¦' + flat[k]\n    })\n    .join('|')\n\n  // return flat;\n}\nmodule.exports = pack\n","const encoding = require('../encoding')\n\n//the symbols are at the top of the array.\nmodule.exports = function(t) {\n  //... process these lines\n  const reSymbol = new RegExp('([0-9A-Z]+):([0-9A-Z]+)')\n  for (let i = 0; i < t.nodes.length; i++) {\n    const m = reSymbol.exec(t.nodes[i])\n    if (!m) {\n      t.symCount = i\n      break\n    }\n    t.syms[encoding.fromAlphaCode(m[1])] = encoding.fromAlphaCode(m[2])\n  }\n  //remove from main node list\n  t.nodes = t.nodes.slice(t.symCount, t.nodes.length)\n}\n","const parseSymbols = require('./symbols')\nconst encoding = require('../encoding')\n\n// References are either absolute (symbol) or relative (1 - based)\nconst indexFromRef = function(trie, ref, index) {\n  const dnode = encoding.fromAlphaCode(ref)\n  if (dnode < trie.symCount) {\n    return trie.syms[dnode]\n  }\n  return index + dnode + 1 - trie.symCount\n}\n\nconst toArray = function(trie) {\n  const all = []\n  const crawl = (index, pref) => {\n    let node = trie.nodes[index]\n    if (node[0] === '!') {\n      all.push(pref)\n      node = node.slice(1) //ok, we tried. remove it.\n    }\n    const matches = node.split(/([A-Z0-9,]+)/g)\n    for (let i = 0; i < matches.length; i += 2) {\n      const str = matches[i]\n      const ref = matches[i + 1]\n      if (!str) {\n        continue\n      }\n\n      const have = pref + str\n      //branch's end\n      if (ref === ',' || ref === undefined) {\n        all.push(have)\n        continue\n      }\n      const newIndex = indexFromRef(trie, ref, index)\n      crawl(newIndex, have)\n    }\n  }\n  crawl(0, '')\n  return all\n}\n\n//PackedTrie - Trie traversal of the Trie packed-string representation.\nconst unpack = function(str) {\n  const trie = {\n    nodes: str.split(';'), //that's all ;)!\n    syms: [],\n    symCount: 0\n  }\n  //process symbols, if they have them\n  if (str.match(':')) {\n    parseSymbols(trie)\n  }\n  return toArray(trie)\n}\n\nmodule.exports = unpack\n","const unpack = require('./unpack')\n\nmodule.exports = function(str) {\n  //turn the weird string into a key-value object again\n  const obj = str.split('|').reduce((h, s) => {\n    const arr = s.split('¦')\n    h[arr[0]] = arr[1]\n    return h\n  }, {})\n  const all = {}\n  Object.keys(obj).forEach(function(cat) {\n    const arr = unpack(obj[cat])\n    //special case, for botched-boolean\n    if (cat === 'true') {\n      cat = true\n    }\n    for (let i = 0; i < arr.length; i++) {\n      const k = arr[i]\n      if (all.hasOwnProperty(k) === true) {\n        if (Array.isArray(all[k]) === false) {\n          all[k] = [all[k], cat]\n        } else {\n          all[k].push(cat)\n        }\n      } else {\n        all[k] = cat\n      }\n    }\n  })\n  return all\n}\n","const efrt = {\n  pack: require('./pack/index'),\n  unpack: require('./unpack/index')\n}\n\n//and then all-the-exports...\nif (typeof self !== 'undefined') {\n  self.efrt = efrt // Web Worker\n} else if (typeof window !== 'undefined') {\n  window.efrt = efrt // Browser\n} else if (typeof global !== 'undefined') {\n  global.efrt = efrt // NodeJS\n}\n//don't forget amd!\nif (typeof define === 'function' && define.amd) {\n  define(efrt)\n}\n//then for some reason, do this too!\nif (typeof module !== 'undefined') {\n  module.exports = efrt\n}\n"],"names":["commonPrefix","w1","w2","len","Math","min","length","prefix","slice","unique","a","sort","i","splice","Histogram","this","counts","methods","init","sym","undefined","add","n","countOf","highest","top","sorted","keys","Object","push","b","forEach","k","prototype","BASE","seq","cache","split","reduce","h","c","toAlphaCode","places","range","s","d","String","fromCharCode","fromAlphaCode","pow","charCodeAt","config","NODE_SEP","KEY_VAL","STRING_SEP","TERMINAL_PREFIX","nodeLine","self","node","line","sep","isTerminal","props","nodeProps","prop","syms","_n","ref","encoding","symCount","_g","analyzeRefs","visited","histRel","histAbs","symbolCount","savings","best","sCount","defSize","nodeCount","numberNodes","pos","nodes","unshift","pack","optimize","root","prepDFS","join","NOT_ALLOWED","RegExp","insertWords","words","toLowerCase","fns","match","insert","word","_insert","lastWord","freeze","uniqueNode","combineSuffixNode","next","addTerminal","wordCount","nodesOnly","countDegree","collapseChains","_c","sig","shared","suffixes","cNext","vCur","_v","_d","child","other","Trie","suffixCounts","isArray","input","toString","call","handleFormats","str","obj","flat","val","hasOwnProperty","defineProperty","writable","enumerable","configurable","value","t","map","reSymbol","m","exec","indexFromRef","trie","index","dnode","toArray","all","crawl","pref","matches","have","newIndex","unpack","parseSymbols","arr","cat","Array","efrt","require$$0","require$$1","window","global","module"],"mappings":"+PAAA,MAAMA,aAAe,SAASC,EAAIC,GAChC,IAAIC,EAAMC,KAAKC,IAAIJ,EAAGK,OAAQJ,EAAGI,QACjC,KAAOH,EAAM,GAAG,CACd,MAAMI,EAASN,EAAGO,MAAM,EAAGL,GAC3B,GAAII,IAAWL,EAAGM,MAAM,EAAGL,GACzB,OAAOI,EAETJ,GAAO,EAET,MAAO,IAIHM,OAAS,SAASC,GACtBA,EAAEC,OACF,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAEJ,OAAQM,IACxBF,EAAEE,EAAI,KAAOF,EAAEE,IACjBF,EAAEG,OAAOD,EAAG,IAKlB,QAAiB,CACfZ,aAAcA,aACdS,OAAQA,QCxBV,MAAMK,UAAY,WAChBC,KAAKC,OAAS,IAGVC,QAAU,CACdC,KAAM,SAASC,QACYC,IAArBL,KAAKC,OAAOG,KACdJ,KAAKC,OAAOG,GAAO,IAGvBE,IAAK,SAASF,EAAKG,QACPF,IAANE,IACFA,EAAI,GAENP,KAAKG,KAAKC,GACVJ,KAAKC,OAAOG,IAAQG,GAEtBC,QAAS,SAASJ,GAEhB,OADAJ,KAAKG,KAAKC,GACHJ,KAAKC,OAAOG,IAErBK,QAAS,SAASC,GAChB,IAAIC,EAAS,GACb,MAAMC,EAAOC,OAAOD,KAAKZ,KAAKC,QAC9B,IAAK,IAAIJ,EAAI,EAAGA,EAAIe,EAAKrB,OAAQM,IAAK,CACpC,MAAMO,EAAMQ,EAAKf,GACjBc,EAAOG,KAAK,CAACV,EAAKJ,KAAKC,OAAOG,KAQhC,OANAO,EAAOf,KAAK,SAASD,EAAGoB,GACtB,OAAOA,EAAE,GAAKpB,EAAE,KAEde,IACFC,EAASA,EAAOlB,MAAM,EAAGiB,IAEpBC,IAGXE,OAAOD,KAAKV,SAASc,QAAQ,SAASC,GACpClB,UAAUmB,UAAUD,GAAKf,QAAQe,KAEnC,cAAiBlB,UCvCjB,MAAMoB,KAAO,GAEPC,IAAM,uCACNC,MAAQD,IAAIE,MAAM,IAAIC,OAAO,SAASC,EAAGC,EAAG5B,GAEhD,OADA2B,EAAEC,GAAK5B,EACA2B,GACN,IAGGE,YAAc,SAASnB,GAC3B,QAAeF,IAAXe,IAAIb,GACN,OAAOa,IAAIb,GAEb,IAAIoB,EAAS,EACTC,EAdO,GAePC,EAAI,GAER,KAAOtB,GAAKqB,EAAOrB,GAAKqB,EAAOD,IAAUC,GAjB9B,IAkBX,KAAOD,KAAU,CACf,MAAMG,EAAIvB,EAnBD,GAoBTsB,EAAIE,OAAOC,cAAcF,EAAI,GAAK,GAAK,IAAMA,GAAKD,EAClDtB,GAAKA,EAAIuB,GArBA,GAuBX,OAAOD,GAGHI,cAAgB,SAASJ,GAC7B,QAAiBxB,IAAbgB,MAAMQ,GACR,OAAOR,MAAMQ,GAEf,IAAItB,EAAI,EACJoB,EAAS,EACTC,EAhCO,GAiCPM,EAAM,EAEV,KAAOP,EAASE,EAAEtC,OAAQgB,GAAKqB,EAAOD,IAAUC,GAnCrC,IAoCX,IAAK,IAAI/B,EAAIgC,EAAEtC,OAAS,EAAGM,GAAK,EAAGA,IAAKqC,GApC7B,GAoC0C,CACnD,IAAIJ,EAAID,EAAEM,WAAWtC,GAAK,GACtBiC,EAAI,KACNA,GAAK,GAEPvB,GAAKuB,EAAII,EAEX,OAAO3B,GAGT,aAAiB,CACfmB,YAAaA,YACbO,cAAeA,eC/CjB,MAAMG,OAAS,CACbC,SAAU,IACVC,QAAS,IACTC,WAAY,IACZC,gBAAiB,IACjBrB,KAAM,IAkCFsB,SAAW,SAASC,EAAMC,GAC9B,IAAIC,EAAO,GACTC,EAAM,GAEJH,EAAKI,WAAWH,KAClBC,GAAQR,OAAOI,iBAGjB,MAAMO,EAAQL,EAAKM,UAAUL,GAC7B,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAAK,CACrC,MAAMoD,EAAOF,EAAMlD,GACnB,GAA0B,iBAAf8C,EAAKM,GAAoB,CAClCL,GAAQC,EAAMI,EACdJ,EAAMT,OAAOG,WACb,SAEF,GAAIG,EAAKQ,KAAKP,EAAKM,GAAME,IAAK,CAC5BP,GAAQC,EAAMI,EAAOP,EAAKQ,KAAKP,EAAKM,GAAME,IAC1CN,EAAM,GACN,SAEF,IAAIO,EAAMC,SAAS3B,YAAYiB,EAAKQ,GAAKR,EAAKM,GAAME,GAAK,EAAIT,EAAKY,UAE9DX,EAAKM,GAAMM,IAAMH,EAAI7D,QAAUoD,EAAKM,GAAMM,GAAGhE,QAAkC,IAAxBoD,EAAKA,EAAKM,GAAMM,KAEzEX,GAAQC,EAAMI,GADdG,EAAMT,EAAKM,GAAMM,IAEjBV,EAAMT,OAAOG,aAGfK,GAAQC,EAAMI,EAAOG,EACrBP,EAAM,IAER,OAAOD,GAGHY,YAAc,SAASd,EAAMC,GACjC,GAAID,EAAKe,QAAQd,GACf,OAEF,MAAMI,EAAQL,EAAKM,UAAUL,GAAM,GACnC,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAAK,CACrC,MAAMoD,EAAOF,EAAMlD,GACbuD,EAAMT,EAAKQ,GAAKR,EAAKM,GAAME,GAAK,EAElCC,EAAMhB,OAAOjB,MACfuB,EAAKgB,QAAQpD,IAAI8C,GAInBV,EAAKiB,QAAQrD,IAAIqC,EAAKM,GAAME,GAAIE,SAAS3B,YAAY0B,GAAK7D,OAAS,GACnEiE,YAAYd,EAAMC,EAAKM,MAIrBW,YAAc,SAASlB,GAC3BA,EAAKiB,QAAUjB,EAAKiB,QAAQlD,QAAQ2B,OAAOjB,MAC3C,MAAM0C,EAAU,GAChBA,GAAS,GAAK,EACd,IAAIC,EAAO,EACTC,EAAS,EACX,MAAMC,EAAU,EAAIX,SAAS3B,YAAYgB,EAAKuB,WAAW1E,OACzD,IAAK,IAAIa,EAAM,EAAGA,EAAMgC,OAAOjB,WACHd,IAAtBqC,EAAKiB,QAAQvD,GADkBA,IAInCyD,EAAQzD,GACNsC,EAAKiB,QAAQvD,GAAK,GAClB4D,EACAtB,EAAKgB,QAAQlD,QAAQ4B,OAAOjB,KAAOf,EAAM,GACzCyD,EAAQzD,EAAM,GACZyD,EAAQzD,IAAQ0D,IAClBA,EAAOD,EAAQzD,GACf2D,EAAS3D,EAAM,GAGnB,OAAO2D,GAGHG,YAAc,SAASxB,EAAMC,GAEjC,QAAgBtC,IAAZsC,EAAKQ,GACP,OAEF,MAAMJ,EAAQL,EAAKM,UAAUL,GAAM,GACnC,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAChCqE,YAAYxB,EAAMC,EAAKI,EAAMlD,KAE/B8C,EAAKQ,GAAKT,EAAKyB,MACfzB,EAAK0B,MAAMC,QAAQ1B,IAGf2B,KAAO,SAAS5B,GACpBA,EAAK0B,MAAQ,GACb1B,EAAKuB,UAAY,EACjBvB,EAAKQ,KAAO,GACZR,EAAKY,SAAW,EAChBZ,EAAKyB,IAAM,EAEXzB,EAAK6B,WAEL7B,EAAKiB,QAAU,IAAI5D,UACnB2C,EAAKgB,QAAU,IAAI3D,UAEnBmE,YAAYxB,EAAMA,EAAK8B,MACvB9B,EAAKuB,UAAYvB,EAAK0B,MAAM7E,OAE5BmD,EAAK+B,UACLjB,YAAYd,EAAMA,EAAK8B,MACvB9B,EAAKY,SAAWM,YAAYlB,GAC5B,IAAK,IAAItC,EAAM,EAAGA,EAAMsC,EAAKY,SAAUlD,IACrCsC,EAAKQ,KAAKR,EAAKiB,QAAQvD,GAAK,IAAMiD,SAAS3B,YAAYtB,GAEzD,IAAK,IAAIP,EAAI,EAAGA,EAAI6C,EAAKuB,UAAWpE,IAClC6C,EAAK0B,MAAMvE,GAAK4C,SAASC,EAAMA,EAAK0B,MAAMvE,IAG5C,IAAK,IAAIO,EAAMsC,EAAKY,SAAW,EAAGlD,GAAO,EAAGA,IAC1CsC,EAAK0B,MAAMC,QACThB,SAAS3B,YAAYtB,GACnBgC,OAAOE,QACPe,SAAS3B,YAAYgB,EAAKuB,UAAYvB,EAAKiB,QAAQvD,GAAK,GAAK,IAInE,OAAOsC,EAAK0B,MAAMM,KAAKtC,OAAOC,WAGhC,WAAiBiC,KCtKjB,MAAMK,YAAc,IAAIC,OAAO,kBAE/B,cAAiB,CAEfC,YAAa,SAASC,GACpB,QAAczE,IAAVyE,EAAJ,CAGqB,iBAAVA,IACTA,EAAQA,EAAMxD,MAAM,eAEtB,IAAK,IAAIzB,EAAI,EAAGA,EAAIiF,EAAMvF,OAAQM,IAChCiF,EAAMjF,GAAKiF,EAAMjF,GAAGkF,cAEtBC,IAAItF,OAAOoF,GACX,IAAK,IAAIjF,EAAI,EAAGA,EAAIiF,EAAMvF,OAAQM,IACI,OAAhCiF,EAAMjF,GAAGoF,MAAMN,cACjB3E,KAAKkF,OAAOJ,EAAMjF,MAKxBqF,OAAQ,SAASC,GACfnF,KAAKoF,QAAQD,EAAMnF,KAAKwE,MACxB,MAAMa,EAAWrF,KAAKqF,SAItB,GAHArF,KAAKqF,SAAWF,EAEDH,IAAI/F,aAAakG,EAAME,KACvBA,EACb,OAGF,MAAMC,EAAStF,KAAKuF,WAAWF,EAAUF,EAAMnF,KAAKwE,MAChDc,GACFtF,KAAKwF,kBAAkBF,IAI3BF,QAAS,SAASD,EAAMxC,GACtB,IAAInD,EAAQiG,EAGZ,GAAoB,IAAhBN,EAAK5F,OACP,OAIF,MAAMqB,EAAOC,OAAOD,KAAK+B,GACzB,IAAK,IAAI9C,EAAI,EAAGA,EAAIe,EAAKrB,OAAQM,IAAK,CACpC,MAAMoD,EAAOrC,EAAKf,GAElB,GAAsB,KADtBL,EAASwF,IAAI/F,aAAakG,EAAMlC,IACrB1D,OAAX,CAIA,GAAI0D,IAASzD,GAAgC,iBAAfmD,EAAKM,GAEjC,YADAjD,KAAKoF,QAAQD,EAAK1F,MAAMD,EAAOD,QAASoD,EAAKM,IAI/C,GAAIA,IAASkC,GAA8B,iBAAfxC,EAAKM,GAC/B,OAQF,OANAwC,EAAO,IACFxC,EAAKxD,MAAMD,EAAOD,SAAWoD,EAAKM,GACvCjD,KAAK0F,YAAYD,EAAMN,EAAOA,EAAK1F,MAAMD,EAAOD,gBACzCoD,EAAKM,GACZN,EAAKnD,GAAUiG,OACfzF,KAAK2F,aAKP3F,KAAK0F,YAAY/C,EAAMwC,GACvBnF,KAAK2F,aASPD,YAAa,SAAS/C,EAAMM,GAC1B,GAAIA,EAAK1D,QAAU,EAEjB,YADAoD,EAAKM,GAAQ,GAGf,MAAMwC,EAAO,GACb9C,EAAKM,EAAK,IAAMwC,EAChBzF,KAAK0F,YAAYD,EAAMxC,EAAKxD,MAAM,KAMpCuD,UAAW,SAASL,EAAMiD,GACxB,MAAM7C,EAAQ,GACd,IAAK,MAAME,KAAQN,EACJ,KAATM,GAA2B,MAAZA,EAAK,KACjB2C,GAAmC,iBAAfjD,EAAKM,IAC5BF,EAAMjC,KAAKmC,IAKjB,OADAF,EAAMnD,OACCmD,GAGTwB,SAAU,WACRvE,KAAKwF,kBAAkBxF,KAAKwE,MAC5BxE,KAAKyE,UACLzE,KAAK6F,YAAY7F,KAAKwE,MACtBxE,KAAKyE,UACLzE,KAAK8F,eAAe9F,KAAKwE,OAI3BgB,kBAAmB,SAAS7C,GAE1B,GAAIA,EAAKoD,GACP,OAAOpD,EAIT,IAAIqD,EAAM,GACNhG,KAAK8C,WAAWH,IAClBqD,EAAIlF,KAAK,KAEX,MAAMiC,EAAQ/C,KAAKgD,UAAUL,GAC7B,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAAK,CACrC,MAAMoD,EAAOF,EAAMlD,GACO,iBAAf8C,EAAKM,IACdN,EAAKM,GAAQjD,KAAKwF,kBAAkB7C,EAAKM,IACzC+C,EAAIlF,KAAKmC,GACT+C,EAAIlF,KAAK6B,EAAKM,GAAM8C,KAEpBC,EAAIlF,KAAKmC,GAGb+C,EAAMA,EAAItB,KAAK,KAEf,MAAMuB,EAASjG,KAAKkG,SAASF,GAC7B,OAAIC,IAGJjG,KAAKkG,SAASF,GAAOrD,EACrBA,EAAKoD,GAAK/F,KAAKmG,QACRxD,IAGT8B,QAAS,WACPzE,KAAKoG,QAGP3C,QAAS,SAASd,GAChB,OAAIA,EAAK0D,KAAOrG,KAAKoG,OAGrBzD,EAAK0D,GAAKrG,KAAKoG,MACR,IAGTP,YAAa,SAASlD,GAKpB,QAJgBtC,IAAZsC,EAAK2D,KACP3D,EAAK2D,GAAK,GAEZ3D,EAAK2D,KACDtG,KAAKyD,QAAQd,GACf,OAEF,MAAMI,EAAQ/C,KAAKgD,UAAUL,GAAM,GACnC,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAChCG,KAAK6F,YAAYlD,EAAKI,EAAMlD,MAKhCiG,eAAgB,SAASnD,GACvB,IAAIM,EAAMF,EAAOwD,EAAO1G,EACxB,IAAIG,KAAKyD,QAAQd,GAAjB,CAIA,IADAI,EAAQ/C,KAAKgD,UAAUL,GAClB9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAGP,iBADrB0G,EAAQ5D,EADRM,EAAOF,EAAMlD,OAKbG,KAAK8F,eAAeS,QAEHlG,IAAbkG,EAAMhD,IAAkC,IAAbgD,EAAMD,IAAgC,IAApBC,EAAMhD,GAAGhE,gBACjDoD,EAAKM,GAEZN,EADAM,GAAQsD,EAAMhD,IACDgD,EAAMA,EAAMhD,MAIR,IAAjBR,EAAMxD,QAAiBS,KAAK8C,WAAWH,KACzCA,EAAKY,GAAKN,KAIdH,WAAY,SAASH,GACnB,QAASA,EAAK,KAKhB4C,WAAY,SAASJ,EAAMqB,EAAO7D,GAChC,MAAMI,EAAQ/C,KAAKgD,UAAUL,GAAM,GACnC,IAAK,IAAI9C,EAAI,EAAGA,EAAIkD,EAAMxD,OAAQM,IAAK,CACrC,MAAMoD,EAAOF,EAAMlD,GACnB,GAAIoD,IAASkC,EAAK1F,MAAM,EAAGwD,EAAK1D,QAC9B,OAAI0D,IAASuD,EAAM/G,MAAM,EAAGwD,EAAK1D,QACxBoD,EAAKM,GAEPjD,KAAKuF,WAAWJ,EAAK1F,MAAMwD,EAAK1D,QAASiH,EAAM/G,MAAMwD,EAAK1D,QAASoD,EAAKM,MAMrFqB,KAAM,WACJ,OAAOA,OAAKtE,QCjNhB,MAAMyG,KAAO,SAAS3B,GACpB9E,KAAKwE,KAAO,GACZxE,KAAKqF,SAAW,GAChBrF,KAAKkG,SAAW,GAChBlG,KAAK0G,aAAe,GACpB1G,KAAKmG,MAAQ,EACbnG,KAAK2F,UAAY,EACjB3F,KAAK6E,YAAYC,GACjB9E,KAAKoG,KAAO,GAEdvF,OAAOD,KAAKV,WAASc,QAAQ,SAASC,GACpCwF,KAAKvF,UAAUD,GAAKf,UAAQe,KAE9B,SAAiBwF,KC7BjB,MAAME,QAAU,SAASC,GACvB,MAAiD,mBAA1C/F,OAAOK,UAAU2F,SAASC,KAAKF,IAGlCG,cAAgB,SAASH,GAE7B,OAAIA,MAAAA,EACK,GAGY,iBAAVA,EACFA,EAAMtF,MAAM,OAAOC,OAAO,SAASC,EAAGwF,GAE3C,OADAxF,EAAEwF,IAAO,EACFxF,GACN,IAGDmF,QAAQC,GACHA,EAAMrF,OAAO,SAASC,EAAGwF,GAE9B,OADAxF,EAAEwF,IAAO,EACFxF,GACN,IAGEoF,GAIHtC,OAAO,SAAS2C,GAxBA,IAASL,EAyB7BK,EAvBIL,OAFyBA,EAyBTK,GAtBX,GAGY,iBAAVL,EACFA,EAAMtF,MAAM,OAAOC,OAAO,SAASC,EAAGwF,GAE3C,OADAxF,EAAEwF,IAAO,EACFxF,GACN,IAGDmF,QAAQC,GACHA,EAAMrF,OAAO,SAASC,EAAGwF,GAE9B,OADAxF,EAAEwF,IAAO,EACFxF,GACN,IAGEoF,EAOP,MAAMM,EAAOrG,OAAOD,KAAKqG,GAAK1F,OAAO,SAASC,EAAGP,GAC/C,MAAMkG,EAAMF,EAAIhG,GAGhB,GAAI0F,QAAQQ,GAAM,CAChB,IAAK,IAAItH,EAAI,EAAGA,EAAIsH,EAAI5H,OAAQM,IAC9B2B,EAAE2F,EAAItH,IAAM2B,EAAE2F,EAAItH,KAAO,GACzB2B,EAAE2F,EAAItH,IAAIiB,KAAKG,GAEjB,OAAOO,EAaT,OAV8B,IAA1BA,EAAE4F,eAAeD,IAEnBtG,OAAOwG,eAAe7F,EAAG2F,EAAK,CAC5BG,UAAU,EACVC,YAAY,EACZC,cAAc,EACdC,MAAO,KAGXjG,EAAE2F,GAAKrG,KAAKG,GACLO,GACN,IAQH,OANAX,OAAOD,KAAKsG,GAAMlG,QAAQ,SAASC,GACjC,MAAMyG,EAAI,IAAIjB,KAAKS,EAAKjG,IACxBiG,EAAKjG,GAAKyG,EAAEpD,SAIPzD,OAAOD,KAAKsG,GAChBS,IAAI1G,GACIA,EAAI,IAAMiG,EAAKjG,IAEvByD,KAAK,MAIV,aAAiBJ,eCrEA,SAASoD,GAExB,MAAME,EAAW,IAAIhD,OAAO,2BAC5B,IAAK,IAAI/E,EAAI,EAAGA,EAAI6H,EAAEtD,MAAM7E,OAAQM,IAAK,CACvC,MAAMgI,EAAID,EAASE,KAAKJ,EAAEtD,MAAMvE,IAChC,IAAKgI,EAAG,CACNH,EAAEpE,SAAWzD,EACb,MAEF6H,EAAExE,KAAKG,SAASpB,cAAc4F,EAAE,KAAOxE,SAASpB,cAAc4F,EAAE,IAGlEH,EAAEtD,MAAQsD,EAAEtD,MAAM3E,MAAMiI,EAAEpE,SAAUoE,EAAEtD,MAAM7E,SCX9C,MAAMwI,aAAe,SAASC,EAAM5E,EAAK6E,GACvC,MAAMC,EAAQ7E,SAASpB,cAAcmB,GACrC,OAAI8E,EAAQF,EAAK1E,SACR0E,EAAK9E,KAAKgF,GAEZD,EAAQC,EAAQ,EAAIF,EAAK1E,UAG5B6E,QAAU,SAASH,GACvB,MAAMI,EAAM,GACNC,EAAQ,CAACJ,EAAOK,KACpB,IAAI3F,EAAOqF,EAAK5D,MAAM6D,GACN,MAAZtF,EAAK,KACPyF,EAAItH,KAAKwH,GACT3F,EAAOA,EAAKlD,MAAM,IAEpB,MAAM8I,EAAU5F,EAAKrB,MAAM,iBAC3B,IAAK,IAAIzB,EAAI,EAAGA,EAAI0I,EAAQhJ,OAAQM,GAAK,EAAG,CAC1C,MAAMmH,EAAMuB,EAAQ1I,GACduD,EAAMmF,EAAQ1I,EAAI,GACxB,IAAKmH,EACH,SAGF,MAAMwB,EAAOF,EAAOtB,EAEpB,GAAY,MAAR5D,QAAuB/C,IAAR+C,EAAmB,CACpCgF,EAAItH,KAAK0H,GACT,SAEF,MAAMC,EAAWV,aAAaC,EAAM5E,EAAK6E,GACzCI,EAAMI,EAAUD,KAIpB,OADAH,EAAM,EAAG,IACFD,GAIHM,OAAS,SAAS1B,GACtB,MAAMgB,EAAO,CACX5D,MAAO4C,EAAI1F,MAAM,KACjB4B,KAAM,GACNI,SAAU,GAMZ,OAHI0D,EAAI/B,MAAM,MACZ0D,QAAaX,GAERG,QAAQH,IAGjB,aAAiBU,kBCtDA,SAAS1B,GAExB,MAAMC,EAAMD,EAAI1F,MAAM,KAAKC,OAAO,CAACC,EAAGK,KACpC,MAAM+G,EAAM/G,EAAEP,MAAM,KAEpB,OADAE,EAAEoH,EAAI,IAAMA,EAAI,GACTpH,GACN,IACG4G,EAAM,GAoBZ,OAnBAvH,OAAOD,KAAKqG,GAAKjG,QAAQ,SAAS6H,GAChC,MAAMD,EAAMF,SAAOzB,EAAI4B,IAEX,SAARA,IACFA,GAAM,GAER,IAAK,IAAIhJ,EAAI,EAAGA,EAAI+I,EAAIrJ,OAAQM,IAAK,CACnC,MAAMoB,EAAI2H,EAAI/I,IACgB,IAA1BuI,EAAIhB,eAAenG,IACS,IAA1B6H,MAAMnC,QAAQyB,EAAInH,IACpBmH,EAAInH,GAAK,CAACmH,EAAInH,GAAI4H,GAElBT,EAAInH,GAAGH,KAAK+H,GAGdT,EAAInH,GAAK4H,KAIRT,wCC7BT,MAAMW,EAAO,CACXzE,KAAM0E,SACNN,OAAQO,YAIU,oBAATvG,KACTA,KAAKqG,KAAOA,EACe,oBAAXG,OAChBA,OAAOH,KAAOA,OACa,IAAXI,iBAChBA,eAAOJ,KAAOA,GAQdK,UAAiBL"}