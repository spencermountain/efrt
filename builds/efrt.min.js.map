{"version":3,"file":"efrt.min.js","sources":["../src/pack/fns.js","../src/pack/histogram.js","../src/encoding.js","../src/pack/pack.js","../src/pack/methods.js","../src/pack/trie.js","../src/pack/index.js","../src/unpack/unpack.js","../src/unpack/symbols.js","../src/unpack/index.js","../src/index.js"],"sourcesContent":["const commonPrefix = function(w1, w2) {\n  let len = Math.min(w1.length, w2.length)\n  while (len > 0) {\n    const prefix = w1.slice(0, len)\n    if (prefix === w2.slice(0, len)) {\n      return prefix\n    }\n    len -= 1\n  }\n  return ''\n}\n\n/* Sort elements and remove duplicates from array (modified in place) */\nconst unique = function(a) {\n  a.sort()\n  for (let i = 1; i < a.length; i++) {\n    if (a[i - 1] === a[i]) {\n      a.splice(i, 1)\n    }\n  }\n}\n\nmodule.exports = {\n  commonPrefix: commonPrefix,\n  unique: unique\n}\n","const Histogram = function() {\n  this.counts = {}\n}\n\nconst methods = {\n  init: function(sym) {\n    if (this.counts[sym] === undefined) {\n      this.counts[sym] = 0\n    }\n  },\n  add: function(sym, n) {\n    if (n === undefined) {\n      n = 1\n    }\n    this.init(sym)\n    this.counts[sym] += n\n  },\n  countOf: function(sym) {\n    this.init(sym)\n    return this.counts[sym]\n  },\n  highest: function(top) {\n    let sorted = []\n    const keys = Object.keys(this.counts)\n    for (let i = 0; i < keys.length; i++) {\n      const sym = keys[i]\n      sorted.push([sym, this.counts[sym]])\n    }\n    sorted.sort(function(a, b) {\n      return b[1] - a[1]\n    })\n    if (top) {\n      sorted = sorted.slice(0, top)\n    }\n    return sorted\n  }\n}\nObject.keys(methods).forEach(function(k) {\n  Histogram.prototype[k] = methods[k]\n})\nmodule.exports = Histogram\n","'use strict'\nconst BASE = 36\n\nconst seq = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nconst cache = seq.split('').reduce(function(h, c, i) {\n  h[c] = i\n  return h\n}, {})\n\n// 0, 1, 2, ..., A, B, C, ..., 00, 01, ... AA, AB, AC, ..., AAA, AAB, ...\nconst toAlphaCode = function(n) {\n  if (seq[n] !== undefined) {\n    return seq[n]\n  }\n  let places = 1\n  let range = BASE\n  let s = ''\n\n  for (; n >= range; n -= range, places++, range *= BASE) {}\n  while (places--) {\n    const d = n % BASE\n    s = String.fromCharCode((d < 10 ? 48 : 55) + d) + s\n    n = (n - d) / BASE\n  }\n  return s\n}\n\nconst fromAlphaCode = function(s) {\n  if (cache[s] !== undefined) {\n    return cache[s]\n  }\n  let n = 0\n  let places = 1\n  let range = BASE\n  let pow = 1\n\n  for (; places < s.length; n += range, places++, range *= BASE) {}\n  for (let i = s.length - 1; i >= 0; i--, pow *= BASE) {\n    let d = s.charCodeAt(i) - 48\n    if (d > 10) {\n      d -= 7\n    }\n    n += d * pow\n  }\n  return n\n}\n\nmodule.exports = {\n  toAlphaCode: toAlphaCode,\n  fromAlphaCode: fromAlphaCode\n}\n","const Histogram = require('./histogram')\nconst encoding = require('../encoding')\nconst config = {\n  NODE_SEP: ';',\n  KEY_VAL: ':',\n  STRING_SEP: ',',\n  TERMINAL_PREFIX: '!',\n  BASE: 36\n}\n\n// Return packed representation of Trie as a string.\n\n// Return packed representation of Trie as a string.\n//\n// Each node of the Trie is output on a single line.\n//\n// For example Trie(\"the them there thesis this\"):\n// {\n//    \"th\": {\n//      \"is\": 1,\n//      \"e\": {\n//        \"\": 1,\n//        \"m\": 1,\n//        \"re\": 1,\n//        \"sis\": 1\n//      }\n//    }\n//  }\n//\n// Would be reperesented as:\n//\n// th0\n// e0is\n// !m,re,sis\n//\n// The line begins with a '!' iff it is a terminal node of the Trie.\n// For each string property in a node, the string is listed, along\n// with a (relative!) line number of the node that string references.\n// Terminal strings (those without child node references) are\n// separated by ',' characters.\n\nconst nodeLine = function(self, node) {\n  let line = '',\n    sep = ''\n\n  if (self.isTerminal(node)) {\n    line += config.TERMINAL_PREFIX\n  }\n\n  const props = self.nodeProps(node)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    if (typeof node[prop] === 'number') {\n      line += sep + prop\n      sep = config.STRING_SEP\n      continue\n    }\n    if (self.syms[node[prop]._n]) {\n      line += sep + prop + self.syms[node[prop]._n]\n      sep = ''\n      continue\n    }\n    let ref = encoding.toAlphaCode(node._n - node[prop]._n - 1 + self.symCount)\n    // Large reference to smaller string suffix -> duplicate suffix\n    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {\n      ref = node[prop]._g\n      line += sep + prop + ref\n      sep = config.STRING_SEP\n      continue\n    }\n    line += sep + prop + ref\n    sep = ''\n  }\n  return line\n}\n\nconst analyzeRefs = function(self, node) {\n  if (self.visited(node)) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i]\n    const ref = node._n - node[prop]._n - 1\n    // Count the number of single-character relative refs\n    if (ref < config.BASE) {\n      self.histRel.add(ref)\n    }\n    // Count the number of characters saved by converting an absolute\n    // reference to a one-character symbol.\n    self.histAbs.add(node[prop]._n, encoding.toAlphaCode(ref).length - 1)\n    analyzeRefs(self, node[prop])\n  }\n}\n\nconst symbolCount = function(self) {\n  self.histAbs = self.histAbs.highest(config.BASE)\n  const savings = []\n  savings[-1] = 0\n  let best = 0,\n    sCount = 0\n  const defSize = 3 + encoding.toAlphaCode(self.nodeCount).length\n  for (let sym = 0; sym < config.BASE; sym++) {\n    if (self.histAbs[sym] === undefined) {\n      break\n    }\n    savings[sym] =\n      self.histAbs[sym][1] -\n      defSize -\n      self.histRel.countOf(config.BASE - sym - 1) +\n      savings[sym - 1]\n    if (savings[sym] >= best) {\n      best = savings[sym]\n      sCount = sym + 1\n    }\n  }\n  return sCount\n}\n\nconst numberNodes = function(self, node) {\n  // Topological sort into nodes array\n  if (node._n !== undefined) {\n    return\n  }\n  const props = self.nodeProps(node, true)\n  for (let i = 0; i < props.length; i++) {\n    numberNodes(self, node[props[i]]) //recursive\n  }\n  node._n = self.pos++\n  self.nodes.unshift(node)\n}\n\nconst pack = function(self) {\n  self.nodes = []\n  self.nodeCount = 0\n  self.syms = {}\n  self.symCount = 0\n  self.pos = 0\n  // Make sure we've combined all the common suffixes\n  self.optimize()\n\n  self.histAbs = new Histogram()\n  self.histRel = new Histogram()\n\n  numberNodes(self, self.root)\n  self.nodeCount = self.nodes.length\n\n  self.prepDFS()\n  analyzeRefs(self, self.root)\n  self.symCount = symbolCount(self)\n  for (let sym = 0; sym < self.symCount; sym++) {\n    self.syms[self.histAbs[sym][0]] = encoding.toAlphaCode(sym)\n  }\n  for (let i = 0; i < self.nodeCount; i++) {\n    self.nodes[i] = nodeLine(self, self.nodes[i])\n  }\n  // Prepend symbols\n  for (let sym = self.symCount - 1; sym >= 0; sym--) {\n    self.nodes.unshift(\n      encoding.toAlphaCode(sym) +\n        config.KEY_VAL +\n        encoding.toAlphaCode(self.nodeCount - self.histAbs[sym][0] - 1)\n    )\n  }\n\n  return self.nodes.join(config.NODE_SEP)\n}\n\nmodule.exports = pack\n","const fns = require('./fns')\nconst pack = require('./pack')\nconst NOT_ALLOWED = new RegExp('[0-9A-Z,;!:|¦]') //characters banned from entering the trie\n\nmodule.exports = {\n  // Insert words from one big string, or from an array.\n  insertWords: function(words) {\n    if (words === undefined) {\n      return\n    }\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/)\n    }\n    for (let i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase()\n    }\n    fns.unique(words)\n    for (let i = 0; i < words.length; i++) {\n      if (words[i].match(NOT_ALLOWED) === null) {\n        this.insert(words[i])\n      }\n    }\n  },\n\n  insert: function(word) {\n    this._insert(word, this.root)\n    const lastWord = this.lastWord\n    this.lastWord = word\n\n    const prefix = fns.commonPrefix(word, lastWord)\n    if (prefix === lastWord) {\n      return\n    }\n\n    const freeze = this.uniqueNode(lastWord, word, this.root)\n    if (freeze) {\n      this.combineSuffixNode(freeze)\n    }\n  },\n\n  _insert: function(word, node) {\n    let prefix, next\n\n    // Duplicate word entry - ignore\n    if (word.length === 0) {\n      return\n    }\n\n    // Do any existing props share a common prefix?\n    const keys = Object.keys(node)\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i]\n      prefix = fns.commonPrefix(word, prop)\n      if (prefix.length === 0) {\n        continue\n      }\n      // Prop is a proper prefix - recurse to child node\n      if (prop === prefix && typeof node[prop] === 'object') {\n        this._insert(word.slice(prefix.length), node[prop])\n        return\n      }\n      // Duplicate terminal string - ignore\n      if (prop === word && typeof node[prop] === 'number') {\n        return\n      }\n      next = {}\n      next[prop.slice(prefix.length)] = node[prop]\n      this.addTerminal(next, word = word.slice(prefix.length))\n      delete node[prop]\n      node[prefix] = next\n      this.wordCount++\n      return\n    }\n\n    // No shared prefix.  Enter the word here as a terminal string.\n    this.addTerminal(node, word)\n    this.wordCount++\n  },\n\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value == 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal: function(node, prop) {\n    if (prop.length <= 1) {\n      node[prop] = 1\n      return\n    }\n    const next = {}\n    node[prop[0]] = next\n    this.addTerminal(next, prop.slice(1))\n  },\n\n  // Well ordered list of properties in a node (string or object properties)\n  // Use nodesOnly==true to return only properties of child nodes (not\n  // terminal strings.\n  nodeProps: function(node, nodesOnly) {\n    const props = []\n    for (const prop in node) {\n      if (prop !== '' && prop[0] !== '_') {\n        if (!nodesOnly || typeof node[prop] === 'object') {\n          props.push(prop)\n        }\n      }\n    }\n    props.sort()\n    return props\n  },\n\n  optimize: function() {\n    this.combineSuffixNode(this.root)\n    this.prepDFS()\n    this.countDegree(this.root)\n    this.prepDFS()\n    this.collapseChains(this.root)\n  },\n\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode: function(node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node\n    }\n    // Make sure all children are combined and generate unique node\n    // signature for this node.\n    let sig = []\n    if (this.isTerminal(node)) {\n      sig.push('!')\n    }\n    const props = this.nodeProps(node)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (typeof node[prop] === 'object') {\n        node[prop] = this.combineSuffixNode(node[prop])\n        sig.push(prop)\n        sig.push(node[prop]._c)\n      } else {\n        sig.push(prop)\n      }\n    }\n    sig = sig.join('-')\n\n    const shared = this.suffixes[sig]\n    if (shared) {\n      return shared\n    }\n    this.suffixes[sig] = node\n    node._c = this.cNext++\n    return node\n  },\n\n  prepDFS: function() {\n    this.vCur++\n  },\n\n  visited: function(node) {\n    if (node._v === this.vCur) {\n      return true\n    }\n    node._v = this.vCur\n    return false\n  },\n\n  countDegree: function(node) {\n    if (node._d === undefined) {\n      node._d = 0\n    }\n    node._d++\n    if (this.visited(node)) {\n      return\n    }\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      this.countDegree(node[props[i]])\n    }\n  },\n\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains: function(node) {\n    let prop, props, child, i\n    if (this.visited(node)) {\n      return\n    }\n    props = this.nodeProps(node)\n    for (i = 0; i < props.length; i++) {\n      prop = props[i]\n      child = node[prop]\n      if (typeof child !== 'object') {\n        continue\n      }\n      this.collapseChains(child)\n      // Hoist the singleton child's single property to the parent\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        delete node[prop]\n        prop += child._g\n        node[prop] = child[child._g]\n      }\n    }\n    // Identify singleton nodes\n    if (props.length === 1 && !this.isTerminal(node)) {\n      node._g = prop\n    }\n  },\n\n  isTerminal: function(node) {\n    return !!node['']\n  },\n\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode: function(word, other, node) {\n    const props = this.nodeProps(node, true)\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node[prop]\n        }\n        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop])\n      }\n    }\n    return undefined\n  },\n\n  pack: function() {\n    return pack(this)\n  }\n}\n","const methods = require('./methods')\n/*\n A JavaScript implementation of a Trie search datastructure.\nEach node of the Trie is an Object that can contain the following properties:\n      '' - If present (with value == 1), the node is a Terminal Node - the prefix\n          leading to this node is a word in the dictionary.\n      numeric properties (value == 1) - the property name is a terminal string\n          so that the prefix + string is a word in the dictionary.\n      Object properties - the property name is one or more characters to be consumed\n          from the prefix of the test string, with the remainder to be checked in\n          the child node.\n      '_c': A unique name for the node (starting from 1), used in combining Suffixes.\n      '_n': Created when packing the Trie, the sequential node number\n          (in pre-order traversal).\n      '_d': The number of times a node is shared (it's in-degree from other nodes).\n      '_v': Visited in DFS.\n      '_g': For singleton nodes, the name of it's single property.\n */\nconst Trie = function(words) {\n  this.root = {}\n  this.lastWord = ''\n  this.suffixes = {}\n  this.suffixCounts = {}\n  this.cNext = 1\n  this.wordCount = 0\n  this.insertWords(words)\n  this.vCur = 0\n}\nObject.keys(methods).forEach(function(k) {\n  Trie.prototype[k] = methods[k]\n})\nmodule.exports = Trie\n","const Trie = require('./trie')\n\nconst isArray = function(input) {\n  return Object.prototype.toString.call(input) === '[object Array]'\n}\n\nconst handleFormats = function(input) {\n  //null\n  if (input === null || input === undefined) {\n    return {}\n  }\n  //string\n  if (typeof input === 'string') {\n    return input.split(/ +/g).reduce(function(h, str) {\n      h[str] = true\n      return h\n    }, {})\n  }\n  //array\n  if (isArray(input)) {\n    return input.reduce(function(h, str) {\n      h[str] = true\n      return h\n    }, {})\n  }\n  //object\n  return input\n}\n\n//turn an array into a compressed string\nconst pack = function(obj) {\n  obj = handleFormats(obj)\n  //pivot into categories:\n  const flat = Object.keys(obj).reduce(function(h, k) {\n    const val = obj[k]\n    //array version-\n    //put it in several buckets\n    if (isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        h[val[i]] = h[val[i]] || []\n        h[val[i]].push(k)\n      }\n      return h\n    }\n    //normal string/boolean version\n    if (h.hasOwnProperty(val) === false) {\n      //basically h[val]=[]  - support reserved words\n      Object.defineProperty(h, val, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: []\n      })\n    }\n    h[val].push(k)\n    return h\n  }, {})\n  //pack each into a compressed string\n  Object.keys(flat).forEach(function(k) {\n    const t = new Trie(flat[k])\n    flat[k] = t.pack()\n  })\n  // flat = JSON.stringify(flat, null, 0);\n\n  return Object.keys(flat)\n    .map(k => {\n      return k + '¦' + flat[k]\n    })\n    .join('|')\n\n  // return flat;\n}\nmodule.exports = pack\n","const parseSymbols = require('./symbols')\nconst encoding = require('../encoding')\n\n// References are either absolute (symbol) or relative (1 - based)\nconst indexFromRef = function(trie, ref, index) {\n  const dnode = encoding.fromAlphaCode(ref)\n  if (dnode < trie.symCount) {\n    return trie.syms[dnode]\n  }\n  return index + dnode + 1 - trie.symCount\n}\n\nconst toArray = function(trie) {\n  const all = []\n  const crawl = (index, pref) => {\n    let node = trie.nodes[index]\n    if (node[0] === '!') {\n      all.push(pref)\n      node = node.slice(1) //ok, we tried. remove it.\n    }\n    const matches = node.split(/([A-Z0-9,]+)/g)\n    for (let i = 0; i < matches.length; i += 2) {\n      const str = matches[i]\n      const ref = matches[i + 1]\n      if (!str) {\n        continue\n      }\n\n      const have = pref + str\n      //branch's end\n      if (ref === ',' || ref === undefined) {\n        all.push(have)\n        continue\n      }\n      const newIndex = indexFromRef(trie, ref, index)\n      crawl(newIndex, have)\n    }\n  }\n  crawl(0, '')\n  return all\n}\n\n//PackedTrie - Trie traversal of the Trie packed-string representation.\nconst unpack = function(str) {\n  const trie = {\n    nodes: str.split(';'), //that's all ;)!\n    syms: [],\n    symCount: 0\n  }\n  //process symbols, if they have them\n  if (str.match(':')) {\n    parseSymbols(trie)\n  }\n  return toArray(trie)\n}\n\nmodule.exports = unpack\n","const encoding = require('../encoding')\n\n//the symbols are at the top of the array.\nmodule.exports = function(t) {\n  //... process these lines\n  const reSymbol = new RegExp('([0-9A-Z]+):([0-9A-Z]+)')\n  for (let i = 0; i < t.nodes.length; i++) {\n    const m = reSymbol.exec(t.nodes[i])\n    if (!m) {\n      t.symCount = i\n      break\n    }\n    t.syms[encoding.fromAlphaCode(m[1])] = encoding.fromAlphaCode(m[2])\n  }\n  //remove from main node list\n  t.nodes = t.nodes.slice(t.symCount, t.nodes.length)\n}\n","const unpack = require('./unpack')\n\nmodule.exports = function(str) {\n  //turn the weird string into a key-value object again\n  const obj = str.split('|').reduce((h, s) => {\n    const arr = s.split('¦')\n    h[arr[0]] = arr[1]\n    return h\n  }, {})\n  const all = {}\n  Object.keys(obj).forEach(function(cat) {\n    const arr = unpack(obj[cat])\n    //special case, for botched-boolean\n    if (cat === 'true') {\n      cat = true\n    }\n    for (let i = 0; i < arr.length; i++) {\n      const k = arr[i]\n      if (all.hasOwnProperty(k) === true) {\n        if (Array.isArray(all[k]) === false) {\n          all[k] = [all[k], cat]\n        } else {\n          all[k].push(cat)\n        }\n      } else {\n        all[k] = cat\n      }\n    }\n  })\n  return all\n}\n","const efrt = {\n  pack: require('./pack/index'),\n  unpack: require('./unpack/index')\n}\n\n//and then all-the-exports...\nif (typeof self !== 'undefined') {\n  self.efrt = efrt // Web Worker\n} else if (typeof window !== 'undefined') {\n  window.efrt = efrt // Browser\n} else if (typeof global !== 'undefined') {\n  global.efrt = efrt // NodeJS\n}\n//don't forget amd!\nif (typeof define === 'function' && define.amd) {\n  define(efrt)\n}\n//then for some reason, do this too!\nif (typeof module !== 'undefined') {\n  module.exports = efrt\n}\n"],"names":["w1","w2","len","Math","min","length","prefix","slice","a","sort","i","splice","Histogram","this","counts","methods","init","sym","undefined","add","n","countOf","highest","top","sorted","keys","Object","push","b","forEach","k","prototype","seq","cache","split","reduce","h","c","places","range","s","d","String","fromCharCode","pow","charCodeAt","config","nodeLine","self","node","line","sep","isTerminal","props","nodeProps","prop","syms","_n","ref","encoding","symCount","_g","analyzeRefs","visited","histRel","histAbs","numberNodes","pos","nodes","unshift","nodeCount","optimize","root","prepDFS","savings","best","sCount","defSize","symbolCount","join","NOT_ALLOWED","RegExp","insertWords","words","toLowerCase","fns","match","insert","word","_insert","lastWord","freeze","uniqueNode","combineSuffixNode","next","addTerminal","wordCount","nodesOnly","countDegree","collapseChains","_c","sig","shared","suffixes","cNext","vCur","_v","_d","child","other","pack","Trie","suffixCounts","isArray","input","toString","call","obj","str","flat","val","hasOwnProperty","defineProperty","writable","enumerable","configurable","value","t","map","indexFromRef","trie","index","dnode","reSymbol","m","exec","parseSymbols","all","crawl","pref","matches","have","newIndex","toArray","arr","cat","unpack","Array","efrt","require$$0","require$$1","window","global","module"],"mappings":"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"}